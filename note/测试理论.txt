计算机分软件系统 硬件系统
	硬件系统 
		输入
		输出
		控制器+处理器:cpu
		存储设备:内存 外存
				1 内存运算速度快 2 内存数据断电消失 外存不会 3 内存分为 rom只读内存和ram随机内存	
	软件系统
		系统软件
		应用软件

		系统分类
			桌面操作系统 windows(用户群体大) macOS(适合开发) linux(软件少)
			移动设备操作系统 ios android(基于linux)
			服务器操作系统 windows-server(付费 占有率低) linux(安全 稳定 免费 占有率高) 
			嵌入式操作系统 linux(文件很小) 应用于机顶盒 数字电视 等
		应用软件 在操作系统上的软件 qq 网盘 音乐播放器

bit 位 计算机表示信息的最小单位
byte 字节 1byte=8bit 1KB=1024Byte 1MB=1024KB

编程语言
	机器语言 二进制数字
	汇编语言 将常用指令规定成语句
	高级编程语言 c c++ java c# python php javascript node.js 

B/S架构 C/S架构
	b/s 浏览器-服务器 包含客户端浏览器 web应用服务器 数据库服务器 只需要浏览器就可以
	c/s 客户端-服务器 需要安装客户端 
	区别 1 硬件环境不同 c/s专用网络 b/s广域网 2 安全性 c/s安全性高 
		3 系统维护 c/s整体性 开发难度大 b/s相反  4处理问题 c/s处理用户固定 b/s客户分散

计算机网络 osi七层模型
	应用层 应用程序网络展开
	表示层 表示数据形式 完成对传输数据的转化 (数据加密解密)
	会话层 建立维护拆除对话 session缓存
	传输层 建立可靠的端对端链接
	网络层 路由寻址和广播
	数据链路层 将上层数据封装成帧
	物理层 传输二进制bit流

tcp/ip协议 网络通讯协议
	应用层 应用程序相互沟通
	传输层 数据传送 应用程序间通信
	网络互联层 基本的数据封包传送 让每一块数据包到达主机
	网络接口层 接收数据 传输

软件测试定义 通过手工或者工具对被测对象进行测试 验证实际结果与预期结果之间是否存在差异

测试原则 1测试证明软件存在缺陷 无论执行什么样的测试都只能证明当前软件存在缺陷
		2不能执行穷尽测试 有些功能无法将全部情况罗列出来测试 任何测试都有结束时间
		3缺陷存在群集效应 软件一般20%是核心功能 实际中会集中测试这部分 所以发现缺陷的几率会有80% 缺陷集中在20%功能模块中的现象
		4某些测试依赖特殊环境 
		5测试应尽早介入 更好的发现和解决软件中的缺陷 测试应尽早开始
		6杀虫剂效应 同一个测试用例不能执行多次
		7不存在缺陷谬论 任何软件都不是完美的

软件测试的作用
	1通过测试发现并修复软件中的缺陷 提高用户对产品的使用信心
	2测试记录软件运行过程的产生的数据 为决策提供数据支持
	3降低同类型产品开发中遇到问题的风险

测试对象 
	当前测试行业最常测的主题是软件主体功能 但是软件不只有功能需要测试 
	软件可以分为三部分 功能集合 使用说明书 配置数据
	软件从无到有 可以分为几个阶段
		1需求分析阶段 各种需求规格说明书
		2软件架构设计 api接口文档(接口测试)
		3编码实现 源码(白盒测试 单元测试)
		4系统功能 软件主体功能(功能测试 最多)

测试级别 
	软件开发会依据相应的开发模型 测试级别指在这个模型中我们定义的步骤 
	1单元测试 UT unit-test  组成软件的最小的底层代码结构 类 函数 组件等 
	2集成测试 IT integration-test 多个单元模块组合起来 验证他们之间沟通的桥梁是否正常 (接口测试)
	3系统测试 ST system-test 测试人员充当用户对软件功能主体进行测试 (行业最常做测试内容)
	4验收测试 
		01 α测试--内测 
		02 β测试--公测 
		03 UAT测试 user-acceptance-test 客户派自己业务人员对软件测试
		04 验收测试 让用户购买

系统测试分类
	1功能测试 验证软件主体功能是否可用
	2兼容性测试 在不同环境下是否可以使用
	3安全测试 是否只对授权用户提供使用
	4性能测试 软件的消耗资源和产出能力

常见系统测试方法
	1 按测试对象分类 
		白盒测试 软件底层代码
		黑盒测试 软件外在主体功能
		灰盒测试 介于白黑盒之间 接口测试
	2按测试对象是否执行分类
		静态测试 测试不执行
		动态测试 软件在真实使用环境中测试
	3按测试手段分类
		手工测试 手动对软件测试 可以灵活改变操作和环境
		自动化测试 一种是写脚本 另一种使用工具 高效率执行手工无法实现的操作

软件质量 描述软件是否好用 (记忆六大特征)
	1功能性 满足用户需要的功能
	2易用性 易于学习使用
	3可靠性 实现需求中指明的功能
	4效率性 软件性能
	5可维护性 软件有修复功能后继续使用的能力
	6可移植性 从一个平台移植到另一个平台使用的能力

软件测试流程 
	1需求分析
		当前阶段核心目的是梳理清楚我们需要设计的点是什么
		需求来源是需求规格说明书 api文档 竞品分析 个人经验
	2设计用例
		用例是用户为了测试软件某个功能而执行的操作过程
		设计用例有方法(等价类 边界值 判定表)
	3评审用例 对当前用例进行添加或者删除
	4配置环境 
		 当前被测对象运行需要的执行环境(如集成环境)
		 环境分 操作系统 服务器软件 数据库 软件代码执行环境
	5执行用例
		执行用例前先做冒烟测试 就是快速对当前软件核心功能或者主体执行流程进行验证 
		冒烟测试通过才会开展全面测试
	6回归测试及缺陷跟踪
		回归测试指我们将某个缺陷提交给开发 由他们修复 修复完需要测试人员再次进行测试
		缺陷跟踪 测试人员发现某个缺陷后需要对其状态进行跟踪
	7输出测试报告
		将当前测试过程中产生的数据进行可视化输出 方便查看
	8测试结束
		将测试中产生的文档整理归档 方便后续版本使用

软件架构 
	两种 b/s c/s
	1标准(b/s两端都是成熟产品 更标准) 2效率(c/s客户端可以分担数据处理 效率高一些) 3安全(b/s数据传输以http协议进行 http协议明文传输 容易被抓包 相对不安全) 4升级(c/s需要两端都升级) 5开发成本(c/s需要开发客户端 成本高一些)

gzip bzip2 zip
	常用gzip 打包压缩 tar czf a.tar.gz *              bzip2 tar cjf a.tar.bz2  *
			 解压解包 tar zxf a.tar.gz -C xx 指定位置       tar jxf a.tar.bz2 -C xx


开发模型
	瀑布模型  需求分析-设计-编码-实现-软件测试-完成-维护
		优点 开发阶段各个阶段比较清晰 强调早期计划及需求调查 适合稳定需求的产品开发
		改良 每个阶段融入小的迭代工作
	快速原型模型 实现一个基本的原型 用户对原型进行评价 逐步调整 使其满足用户需求
		优点 适合不能确定需求的软件
		缺点 不适合大型系统的开发
	螺旋模型

测试模型
	v模型 (中小企业)
		需求分析-概要设计-详细设计-编码--单元测试-集成测试-系统测试-验收测试
		1单元测试 模块测试 针对单一程序模块进行测试
		2集成测试 组装测试 在单元测试基础上 对所有模块进行测试
		3系统测试 讲软件看做整体进行测试 包括功能 性能 兼容性
		4验收测试 
			内测α
			公测β
			候选版本γ
		优缺点 
			优点 包含底层测试(单元测试)和高层测试(系统测试) 清楚的标识了开发和测试的各个阶段 自上而下逐步求精 每个阶段分工明确 便于项目整体把控
			缺点 自上而下顺序导致测试工作在编码之后 错误不能及时修改 实际中需求变化导致v模型步骤反复执行 返工量大 灵活度小
			改良 每个阶段进行小的迭代
	w模型 (中大型企业) 开发一个v 测试一个v组合起来的模型 双v模型
		需求分析 -- 系统测试设计							交付 -- 验收测试
				概要设计 -- 集成测试设计				实施 -- 系统测试
						详细设计 -- 单元测试设计	集成 -- 集成测试
										编码 -- 单元测试
		优点 开发伴随整个开发周期 需求和设计同样要测试 ;更早介入测试 发现初期缺陷 修复成本低 ;分阶段工作 方便项目整体管理
		缺点 开发和测试依然是线性关系 需求变更和调整 依然不方便; 如果没有文档无法执行w模型; 对成员技术要求高

	h模型 很少用


软件测试分类
	按测试阶段: 
		1单元测试 模块测试 针对单一程序模块进行测试
		2集成测试 组装测试 在单元测试基础上 对所有模块进行测试
		3系统测试 讲软件看做整体进行测试 包括功能 性能 兼容性

	是否覆盖源码: 白盒测试:把盒子打开研究里面程序结构和源码
				 黑盒测试:数据驱动测试 完全不考虑内部结构和特征 只注重软件功能需求
					功能测试: 逻辑功能测试 界面测试 易用性测试 安装测试 兼容性测试
					性能测试: 时间性能 空间性能 一般性能测试 稳定性测试 负载测试 压力测试
				灰盒测试
	是否运行: 静态测试 动态测试
	其他: 回归测试 冒烟测试 随机测试(针对重要功能 新增加功能 特殊情况 以前发生过重大bug的模块二次测试 又叫探索测试 可结合回归测试使用) 验收测试(三种 α β γ)
	是否自动化: 人工测试 自动化测试

测试用例 
	为特定目的设计的一组测试输入 执行条件 和预期结果,以便测试是否满足某个特定需求 (测什么 怎么测)

等价类划分法
	属于黑盒测试 将不能穷举的测试过程进行分类 从而保证完整性和代表性
	步骤 确定有效等价类和无效等价类
		 有效等价类划分 根据需求 注意边界值(极值) 中间随意找个值 
		 无效等价类划分 跟有效等价类相反 其他特殊情况 (中文 英文 特殊符号 空格 空 )
	等价类细节 
		考虑输入长度 输入类型 组成规则 是否为空 是否区分大小写 是否重复 是否去除空格

边界值 
	测试用例书写时 找到边界值和两端的值 分别测试
	   边界值思想 选择边界和刚超过的值 进行测试 边界值和等价类相辅相成 配合使用
	   上点 边界上的点 无论开闭区间
	   离点 离上点最近的点 开区间 离点在域内 闭区间 离点在域外
	   内点  区间内的点
因果图 
	因:输入条件 
	果:输出条件 出结果
	适用于输入条件间有相互制约 相互依赖的情况
	符号: 恒等-有因就有果 没有因没有果
		 非-有因无果 无因有果
		 或-一个条件真 结果为真 条件都假 结果才是假
		 且(与)-条件都真 为真 一个条件为假 结果为假

判定表
	根据因果图做判定表 因果图可以不画
	组成:
		条件桩 所有条件
		动作桩 所有结果
		条件项 针对条件桩取值
		动作项 条件项各种取值情况下的输出结果
	步骤
		列出所有条件桩 动作桩
		填写条件项 动作项 得到初始判定表
		简化判定表
场景法
	用来测试业务流程 分为基本流(正确)和备选流(错误流程)
	冒烟测试中主要采用场景法
	用例场景是用来描述流经用例路径的过程 这个过程从开始到结束遍历用例中所有基本流和备选流
流程分析法
	适用于有先后顺序的测试 用于业务流程 安装流程等 每个流程就是一条用例 测试整体流程是否正确 细节需要使用等价类 边界值等方法
	步骤
		了解需求
		根据需求或界面原型 找出业务流程各页面及其流转关系
		画业务流程图(产品经理 Axure)
		写用例 覆盖所有路径分支
错误推断法
	凭经验直觉设计测试用例 根据之前项目相关相关经验总结

正交表
	从全面的试验中挑选有代表性的点进行测试(均匀分散 整齐可比) 高效率 快速 经济的方法
	Ln（mk）n:表的行数 需要测试组合的次数 k:表的列数 就是控件个数(因素个数) m:每个控件取值个数(各因素的水平数)
	L9（34）有4个控件 每个控件有3个取值 9为需要测试的组合个数 叫4因素3水平
	步骤
		根据控件(因素)和取值数(水平)选择合适的正交表
		控件和取值列举出来 对其编号 
		把控件和取值与选择的正交表进行映射
		根据映射好的正交表编写测试用例
	混合正交法 
		因素(控件)的水平数(取值)不同 无法使用现成的正交表 用工具生成混合正交表(allpairs)
		步骤
			1制作取值表			
				体型 年龄 性别
				胖	老年	 男
				适中 青年 女
				瘦	儿童
			2复制表格中数据到新建txt文件 保存到allpairs中 如test.txt
			3cmd进入保存目录 allpairs.exe test.txt > jieguo.txt

测试用例方法选择
	测试功能和流程 场景法
	需要输入数据 使用等价类划分 配合边界值法
	有条件组合 需要用因果图制做判定表
	配置类软件 组合多 用正交表执行
	没有达到覆盖标准 就要增加测试用例
	依靠经验(错误推断法)


软件缺陷
	缺陷就是软件的问题 表现为没有满足用户需求
	哪些属于软件缺陷
		软件未达到规格说明书表明的功能
		软件出现规格说明书指明不会出现的错误
		软件功能超出说明书指明范围
		软件未达到说明书虽未明确指明但应该达到的目标
		测试人员或用户觉得不好的地方
	缺陷表现形式
		功能,特性没有实现或者部分实现
		设计不合理,功能不明确,逻辑不清楚或存在矛盾
		实际结果和期望结果不同
		未达到规格说明书要求的性能指标
		运行出错 包括系统崩溃 运行出错中断 界面混乱
		数据不正确 精度不够 不完整或格式不统一
		用户不能接受的问题 如等待时间长 界面不美观
		硬件或软件的其他问题
	缺陷状态
		提交-测试人员提交缺陷给程序员 submited
		打开-待处理	open
		拒绝-开发认为不是缺陷 rejected
		修复-开发修复缺陷后提交的状态 resolved
		关闭-测试经过回归测试 认为缺陷解决 将其关闭 closed
		推迟-可以在后续版本解决 要写出修复日期或版本 later
	缺陷严重程度及优先级
		low-表面错误 如错别字 --时间资源允许下修复 最低
		medium-影响某个相对独立的功能 特定条件 与需求不一致 或断断续续出问题 --不会延迟发布 以后修复 低
		high-功能点未实现 不符合用户需求 导致数据丢失 --发布前修复 中
		veryhigh-频繁死机 大部分功能不能使用 --高
		critical-系统瘫痪 异常退出 死循环 严重计算错误 --最高优先级
	缺陷分类
		系统缺陷
		数据缺陷
		数据库缺陷
		接口缺陷
		功能缺陷
		安全性缺陷
		兼容性缺陷
		性能缺陷
		界面缺陷
		建议
缺陷信息 
	缺陷ID			唯一的缺陷ID，可以根据该ID追踪缺陷
	*缺陷状态		缺陷状态指缺陷通过一个跟踪修复过程的进展情况
	*缺陷标题		描述缺陷的标题
	*缺陷的严重程度	对软件产品的影响程度，分致命、较严重、严重、一般、低
	*缺陷的优先级	    缺陷修复的先后顺序，即哪些缺陷优先修正，哪些稍后修正
	*缺陷所属模块 	缺陷所属的项目和模块，要能较精确的定位至模块
	缺陷记录者		提交缺陷的人员姓名
	缺陷提交时间		缺陷提交的时间
	缺陷处理人		处理缺陷的处理人
	处理结果描述		对处理结果的描述，描述处理情况和代码修改说明
	缺陷处理时间		缺陷处理的时间
	缺陷验证人		对被处理缺陷验证的验证人（回测者）
	验证结果描述		对验证结果的描述（通过、不通过）
	*缺陷详细描述 	缺陷的重现步骤
	缺陷环境说明		对测试环境的描述
	必要的附件		如涉及到附件的或错误现象的图片等。

缺陷报告注意事项
	尽量保证缺陷可以重现
	简洁 准确 完整
	一个缺陷报告写一个缺陷
缺陷书写规范
	标题简洁 提供缺陷本质信息即可
	复现步骤要详细 用数字编号
	实际结果要描述清楚复现后的结果
	列出期望结果
	提供附件
	提供严重性属性和其他公司需要填写的属性
	注意:
		避免情绪化语言和强调标点符号
		避免模糊词语
		避免自认为幽默的语言
		避免提交不确定的缺陷
缺陷报告内容
	缺陷id 测试日期 
	测试人员 bug类型 
	功能模块 浏览器
	严重程度 优先级
	概要
	复现步骤
	解决者 解决日期
	解决方案

缺陷处理流程
	提交缺陷--分配缺陷--是否重复?(是 关闭缺陷)--bug?(否 关闭缺陷)--推迟处理?(否 处理缺陷) --以后处理--处理缺陷--回测缺陷--修改完成(否 继续处理缺陷)--关闭缺陷

缺陷跟踪
	新提交缺陷为新建状态 确认有效后变成打开状态 开发修复后为已修复状态 此时测试需要回归测试 通过后为已解决状态 若问题还存在 为重新打开状态 如果开发认为可以延期 状态为延期 此状态需要讨论确定
缺陷密度 
	每千行代码缺陷数
	缺陷个数/代码行数*1000
缺陷分析关注问题
	正在测试的软件哪个模块问题多
	谁报告的缺陷多
	各类缺陷占比
	开发是否能及时修复缺陷
	一次正确修复的比例
	软件是否能如期发布


八大测试用例设计方法
	等价类划分
	边界值
	判定表
	因果图
	正交法
	场景法
	流程图
	错误推测法

*熟悉项目步骤
	了解项目业务特性(项目用来做什么)
	了解项目角色与用户(给谁用)
	了解项目组织架构图(包括哪些模块)
	了解项目技术栈(使用哪些技术)

熟悉项目信息来源
	已存在文档 需求文档,设计文档,数据库表设计文档,测试用例,用户手册
	现有环境 开发环境,测试环境,线上环境
	其他成员 测试组长,开发人员,产品经理
组织架构图
	反映项目中各子系统之间和各元素之间的关系 反映各模块及各模块下面子模块 及子模块之下的模块之间的关系
	作用:
		帮助整体理解项目
		理解业务之间关联性
	绘制原则
		后台 系统-子系统-模块-子模块 见到具体页面为止
		前台 独立的页面为一个模块 对共同特征的页面归类整理(按业务流程归类)

测试流程(重点)
	1需求分析与评审
		测试在需求评审中职责
			确认自己对需求理解清晰 没有疑惑
			确认需求文档完整与正确性 能指导后期工作
			对需求中不合理地方提出修改意见
	2编写测试计划与测试方案
		测试计划: 描述测试要进行的范围,方法,资源和进度的文档
				内容:明确测试目标与测试范围
					执行计划的角色和职责
					任务进度安排和资源分配
					风险评估和应急计划
					测试的各项标准	
		测试方案: 从技术角度分析需求 明确怎么测 重点是测试策略和技术实现
				内容:测试策略/方法
					测试环境规划
					测试工具设计和选择
		测试计划和方案的区别:
			计划是管理型文档 方案是技术性文档
			计划解决做什么 谁来做, 方案解决怎么做
			内容差异 上面各自内容
	3*设计测试用例与评审
		同行评审 项目评审
	4*执行测试用例与缺陷跟踪
		执行测试用例步骤
			查看用例标题 确定目标
			检查预置条件
			按步骤执行用例
			实际结果与预期结果比对
		缺陷跟踪 
			提交缺陷报告包含 
				id 标题 模块 优先级 严重程度 复现步骤 预期结果 实际结果 缺陷状态 缺陷类型
			跟踪缺陷
				新建 打开 已修复 关闭 重新打开 拒绝 延期
	5编写测试报告


注册功能
  	设计测试用例
		设计测试用例方法 等价类划分法和边界值结合--注册
		用例设计步骤
			1需求分析 输入分析  输入内容 长度 类型 是否为空 是否重复
					  处理分析 正常处理 异常处理
					  输出分析 前台 后台 数据库
			2划分等价类
					有效等价类 无效等价类
			3设计测试用例 
					id 标题 模块 优先级 预置条件 测试步骤 测试数据 预期结果
	执行测试用例与缺陷跟踪
		测试流程第四步
轮播图
	设计测试用例
		设计测试用例方法 需求--需求点--用例 需求拆分成需求点 --轮播图 购物车
		用例设计步骤
			1需求分析
			2需求拆分成测试点
			3设计测试用例
	执行测试用例与缺陷跟踪
		测试流程第四步

购物车
	设计测试用例
		设计测试用例方法 需求--需求点--用例 需求拆分成需求点 --轮播图 购物车
		用例设计步骤
			1需求分析
			2需求拆分成测试点
			3设计测试用例

	执行测试用例与缺陷跟踪
		测试流程第四步

业务流程测试用例设计
	流程图 用形状和连线表示业务流程执行顺序的图示
	流程图法 用流程图的方式表示用户的使用场景 通过覆盖流程的路径来设计测试用例的方法
	基本流 用户正确操作
	备选流 用户错误操作
	作用: 帮助测试整体理解系统的业务 各模块 子模块在业务上的关联
	使用阶段: 集成测试 系统测试 验收测试 冒烟测试
	设计测试用例步骤
		1需求分析
		2绘制流程图(分析流程节点 节点先后顺序)
			流程图绘制步骤 visio
				确定业务中的操作(节点)
				分析执行顺序
				按业务方向连线
		3设计测试用例(一条流程路径就是一条用例 注意覆盖流程图所有路径)
	
项目测试报告
	非功能性测试
		1兼容性测试
			操作系统 windows(win7 win10) linux(centos6 centos7 Mac ubuntu14 16)
			浏览器 ie 谷歌 火狐
			分辨率
			网络环境
		2效率性(性能)
			2-5-10 2秒内很好 2-5秒可接受 10秒以上严重
		3安全性
			输入数据(敏感信息遮挡 密码不可复制等)
			处理数据(敏感信息用post 传输数据加密)
			输出数据(数据库存储信息加密)
		4易用性
			点击次数
			回车事件处理
			基于特定用户需求考虑(如老年人 残疾人)
		5可维护性
			软件升级
			数据库升级
			代码可维护性
项目测试使用数据库的场景
	数据库确定数据正确
	借助数据库进行缺陷定位
	借助数据库构建数据场景
	借助数据库对数据备份更新

get(参数暴露在url 如查询) post(相对安全 如注册登录)
	请求内容 
		请求行(请求方式 http协议 )
		请求头 浏览器及操作系统信息 支持的语音等
		请求体 传输的参数
	响应内容
		响应行 协议 状态码(200请求成功 ,301重定向 ,客户端404页面找不到 403权限不够 ,5xx服务器)
		响应头 web服务器信息
		响应体
区别	:get参数在url中 post通过请求体传递参数
	get相对post不安全 不适合传递敏感数据
	get浏览器回退无害 post会再次提交数据
	get请求参数会保存在浏览器历史记录中 post不会
	get只能url编码 post支持多种编码
	get参数长度有限制 post没有
	get只接受ascii字符 post无限制















	








